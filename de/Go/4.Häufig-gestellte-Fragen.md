# Go FAQ

> Antworten auf häufige Fragen zu Go

---

## Installation

### Q: Befehl nach Installation nicht gefunden?

**A**: 
- Prüfen Sie, ob Go zur PATH-Umgebungsvariable hinzugefügt wurde
- Standardmäßig wird Go unter C:\Go installiert und muss zu PATH hinzugefügt werden
- Unter Linux/macOS normalerweise manuell zu ~/.bashrc oder ~/.zshrc hinzufügen

### Q: Wie überprüfe ich, ob Go installiert ist?

**A**: 
```bash
go version
go env GOPATH
```

### Q: Wie aktualisiere ich Go?

**A**: 
- Windows: Neue Version herunterladen und neu installieren
- macOS: `brew upgrade go`
- Linux: Neue Version herunterladen ersetzen oder Paketmanager verwenden

---

## Syntax

### Q: Hat Go Ausnahmemechanismen?

**A**: Go hat keine traditionellen Ausnahmen. Fehler werden durch Rückgabewerte übergeben:
```go
result, err := doSomething()
if err != nil {
    // Fehler behandeln
}
```

### Q: Warum können := und var nicht gemischt werden?

**A**: 
- `:=` ist eine kurze Variablendeklaration, innerhalb von Funktionen verwendet
- `var` ist eine explizite Deklaration, kann außerhalb von Funktionen verwendet werden
- Sie können nicht gleichzeitig für dieselbe Variable verwendet werden

### Q: Unterstützt Go Generics?

**A**: Go 1.18+ unterstützt Generics:
```go
func Print[T any](s []T) {
    for _, v := range s {
        fmt.Println(v)
    }
}
```

---

## Parallelität

### Q: Was ist der Unterschied zwischen Goroutinen und Threads?

**A**: 
- Goroutinen werden von der Go-Laufzeit verwaltet, leichter als Threads
- Tausende von Goroutinen können erstellt werden, ohne Ressourcen zu erschöpfen
- Kommunikation erfolgt über Channels

### Q: Sollte man Channels schließen?

**A**: 
- Normalerweise schließt der Sender den Channel
- Empfänger können mit `v, ok := <-ch` prüfen, ob der Channel geschlossen ist
- Senden Sie keine Daten an geschlossene Channels

### Q: Wie wartet man elegant auf das Ende von Goroutinen?

**A**: Verwenden Sie sync.WaitGroup:
```go
var wg sync.WaitGroup

for i := 0; i < 5; i++ {
    wg.Add(1)
    go func(i int) {
        defer wg.Done()
        fmt.Println(i)
    }(i)
}

wg.Wait()
```

---

## Paketverwaltung

### Q: Was ist der Unterschied zwischen GOPATH und Go Modules?

**A**: 
- GOPATH: Alte Methode zur Abhängigkeitsverwaltung, Abhängigkeiten in $GOPATH/src
- Go Module (go.mod): Moderner Ansatz, bessere Versionskontrolle

### Q: Abhängigkeiten werden langsam heruntergeladen?

**A**: 
```bash
# Chinesischen Spiegel verwenden
go env -w GOPROXY=https://goproxy.cn,direct

# Auch einstellbar
go env -w GOPROXY=https://proxy.golang.org,direct
```

### Q: Wie sehe ich Abhängigkeiten?

**A**: 
```bash
go mod graph
go list -m all
```

---

## Leistung

### Q: Wie führe ich Leistungsanalyse durch?

**A**: 
```bash
# CPU-Profilierung
go test -cpuprofile=cpu.out

# Speicherprofilierung
go test -memprofile=mem.out

# Mit pprof analysieren
go tool pprof cpu.out
```

### Q: Wie optimiere ich Go-Programme?

**A**: 
- strings.Builder für String-Verkettung verwenden
- Unnötige Speicherallokationen vermeiden
- Pools (sync.Pool) zur Objektwiederverwendung nutzen
- Channels effizient einsetzen

---

## Tools

### Q: Was ist der Unterschied zwischen go fmt und go vet?

**A**: 
- go fmt: Code-Stil formatieren
- go vet: Statische Analyse, potenzielle Fehler prüfen

### Q: Wie generiere ich Dokumentation?

**A**: 
```bash
go doc <paketname>
go doc <funktionname>

# Lokaler Dokumentationsserver
go doc -http=:6060
```

---

## Fehler

### Q: Was sind häufige Kompilierungsfehler?

**A**: 
- `undefined: xxx` - Variable nicht definiert
- `mismatched types` - Typen stimmen nicht überein
- `invalid character` - Zeichenkodierungsproblem
- `package xxx is not in GOROOT` - Paketpfadfehler

### Q: Was tun bei Runtime-Panic?

**A**: 
- Mit defer und recover abfangen:
```go
func safeCall() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Wiederhergestellt:", r)
        }
    }()
    // Code, der panic auslösen könnte
}
```
