# Spring Cloud Guía de Uso

Esta guía proporciona información detallada sobre cómo usar Spring Cloud para construir microservicios.

## Service Discovery con Eureka

### Habilitar Cliente Eureka

```java
@SpringBootApplication
@EnableEurekaClient
public class MiServicioApplication {
    public static void main(String[] args) {
        SpringApplication.run(MiServicioApplication.class, args);
    }
}
```

### application.yml

```yaml
spring:
  application:
    name: mi-servicio

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
  instance:
    preferIpAddress: true
```

### Descubrir Servicios

```java
@RestController
public class MiController {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    @GetMapping("/servicios/{nombre}")
    public List<ServiceInstance> instancias(@PathVariable String nombre) {
        return discoveryClient.getInstances(nombre);
    }
}
```

## API Gateway con Spring Cloud Gateway

### Configuración Básica

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: servicio-a
          uri: lb://servicio-a
          predicates:
            - Path=/api/a/**
        - id: servicio-b
          uri: lb://servicio-b
          predicates:
            - Path=/api/b/**
```

### Filtros Personalizados

```java
@Component
public class FiltroPersonalizado implements GatewayFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // Lógica del filtro
        return chain.filter(exchange);
    }
}
```

## Circuit Breaker con Resilience4j

### Dependencias

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
```

### Uso

```java
@Service
public class MiServicio {
    
    @CircuitBreaker(name = "miServicio", fallbackMethod = "fallback")
    public String llamarServicio() {
        // Llamar servicio externo
    }
    
    public String fallback(Exception e) {
        return "Respuesta fallback";
    }
}
```

## Configuración Distribuida

### Client Configuration

```yaml
spring:
  cloud:
    config:
      uri: http://localhost:8888
      profile: dev
```

### Actualizar Config en Runtime

```bash
curl -X POST http://localhost:8080/actuator/refresh
```

## Comunicación entre Servicios

### RestTemplate

```java
@LoadBalanced
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate();
}

@Service
public class MiServicio {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public String llamarOtro() {
        return restTemplate.getForObject("http://otro-servicio/api/datos", String.class);
    }
}
```

### WebClient

```java
@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient webClient() {
        return WebClient.builder()
            .baseUrl("http://otro-servicio")
            .build();
    }
}
```

## Distributed Tracing

### Agregar Sleuth

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
```

### Agregar Zipkin

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>
```

## Mejores Prácticas

1. Usa nombres consistentes para servicios
2. Implementa health checks
3. Usa circuit breakers para llamadas externas
4. Centraliza configuración
5. Implementa tracing distribuido
6. Usa comunicación asíncrona cuando sea posible
