# PyTorch 使用手册

## 基础操作

```python
import torch

# 创建张量
x = torch.tensor([1, 2, 3])
y = torch.randn(3, 3)  # 随机初始化

# 基本运算
z = x + y
z = torch.matmul(x, y.view(3, 1))

# 与 NumPy 互转
import numpy as np
a = np.array([1, 2, 3])
t = torch.from_numpy(a)
n = t.numpy()
```

## 神经网络

```python
import torch.nn as nn

# 定义网络
class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.fc1 = nn.Linear(784, 256)
        self.fc2 = nn.Linear(256, 10)
        self.relu = nn.ReLU()
    
    def forward(self, x):
        x = x.view(-1, 784)
        x = self.relu(self.fc1(x))
        x = self.fc2(x)
        return x

model = Net()
```

## 训练循环

```python
import torch.optim as optim

# 损失函数
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# 训练
for epoch in range(epochs):
    for batch_idx, (data, target) in enumerate(train_loader):
        optimizer.zero_grad()
        output = model(data)
        loss = criterion(output, target)
        loss.backward()
        optimizer.step()
    
    print(f'Epoch {epoch+1}, Loss: {loss.item():.4f}')
```

## GPU 训练

```python
# 移到 GPU
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = model.to(device)

# 数据移到 GPU
data, target = data.to(device), target.to(device)

# 训练
output = model(data)
```

## 模型保存

```python
# 保存整个模型
torch.save(model, 'model.pth')

# 仅保存权重
torch.save(model.state_dict(), 'weights.pth')

# 加载
model.load_state_dict(torch.load('weights.pth'))
```
