# Руководство пользователя Go

> Полное руководство по программированию на Go

---

## Быстрый старт

### Первая программа на Go

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

Запуск программы:

```bash
go run main.go
```

---

## Основной синтаксис

### Объявление переменных

```go
// Способ 1: Вывод типа
var name = "Go"

// Способ 2: Явный тип
var age int = 10

// Способ 3: Короткое объявление (внутри функции)
message := "Hello"
```

### Типы данных

```go
// Целые числа
var i int = 10
var ui uint = 10

// Числа с плавающей точкой
var f float64 = 3.14

// Строки
var s string = "Hello"

// Булевы значения
var b bool = true

// Массивы
var arr [5]int = [5]int{1, 2, 3, 4, 5}

// Срезы
slice := []int{1, 2, 3}

// Словари
m := map[string]int{"a": 1, "b": 2}
```

### Управление потоком

```go
// Оператор if
if x > 10 {
    fmt.Println("Больше 10")
} else {
    fmt.Println("Меньше или равно 10")
}

// Цикл for
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// Оператор switch
switch day {
case 1:
    fmt.Println("Понедельник")
default:
    fmt.Println("Другой")
}
```

---

## Функции

### Определение функций

```go
// Базовая функция
func add(a, b int) int {
    return a + b
}

// Несколько возвращаемых значений
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("деление на ноль")
    }
    return a / b, nil
}

// Именованные возвращаемые значения
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}
```

### Вариативные функции

```go
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}

// Использование
sum(1, 2, 3, 4, 5)
```

---

## Структуры и методы

### Определение структур

```go
type Person struct {
    Name string
    Age  int
}

// Метод
func (p Person) SayHello() {
    fmt.Printf("Привет, я %s\n", p.Name)
}
```

### Интерфейсы

```go
type Writer interface {
    Write([]byte) (int, error)
}

type Reader interface {
    Read([]byte) (int, error)
}
```

---

## Параллельное программирование

### Горутины

```go
// Запустить горутину
go func() {
    fmt.Println("Hello from goroutine")
}()

// С аргументами
go func(msg string) {
    fmt.Println(msg)
}("Hello")
```

### Каналы

```go
// Создать канал
ch := make(chan int)

// Отправить данные
ch <- 10

// Получить данные
value := <-ch

// Буферизированный канал
buffered := make(chan int, 10)
```

### Select

```go
select {
case msg := <-ch1:
    fmt.Println("Получено:", msg)
case msg := <-ch2:
    fmt.Println("Получено:", msg)
case <-time.After(time.Second):
    fmt.Println("Таймаут")
}
```

---

## Обработка ошибок

### Определение ошибок

```go
import "errors"

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("деление на ноль")
    }
    return a / b, nil
}
```

### Проверка ошибок

```go
result, err := divide(10, 0)
if err != nil {
    fmt.Println("Ошибка:", err)
    return
}
fmt.Println("Результат:", result)
```

---

## Управление пакетами

### Инициализация модуля

```bash
go mod init github.com/username/project
```

### Добавление зависимостей

```bash
go get github.com/package/name
```

### Упорядочивание зависимостей

```bash
go mod tidy
```

---

## Тестирование

### Модульные тесты

```go
package main

import "testing"

func TestAdd(t *testing.T) {
    result := add(2, 3)
    if result != 5 {
        t.Errorf("Ожидалось 5, получено %d", result)
    }
}
```

Запуск тестов:

```bash
go test ./...
```

### Benchmark-тесты

```go
func BenchmarkHello(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Hello()
    }
}
```

Запуск benchmark:

```bash
go test -bench=.
```

---

## Рекомендации

1. Использовать Go Modules для управления зависимостями
2. Следовать соглашениям о коде Go (запускать `go fmt`)
3. Предпочитать каналы для параллельного общения
4. Избегать глобальных переменных
5. Писать модульные тесты
6. Своевременно обрабатывать ошибки
7. Использовать `context` для управления жизненным циклом запросов
