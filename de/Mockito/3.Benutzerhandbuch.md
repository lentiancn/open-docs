# Mockito Benutzerhandbuch

Detaillierte Anleitung zur Verwendung von Mockito.

## Grundlagen

### Erstellen von Mocks

```java
// Schnittstelle mocken
List<String> mockList = mock(List.class);

// Klasse mocken
MyService myService = mock(MyService.class);
```

### Stubbing

```java
// Einfaches Stubbing
when(mockList.get(0)).thenReturn("first");
when(mockList.size()).thenReturn(10);

// Exception werfen
when(mockList.get(0)).thenThrow(new IndexOutOfBoundsException());

// Mehrere Rückgabewerte
when(mockList.get(anyInt()))
    .thenReturn("first")
    .thenReturn("second")
    .thenThrow(new RuntimeException());
```

### Verifizierung

```java
// Überprüfen, ob eine Methode aufgerufen wurde
verify(mockList).add("one");

// Überprüfen der Anzahl der Aufrufe
verify(mockList, times(1)).add("one");
verify(mockList, never()).clear();
verify(mockList, atLeastOnce()).add("one");
verify(mockList, atMost(5)).add("one");

// Überprüfen der Aufrufreihenfolge
InOrder inOrder = inOrder(mockList, mockList2);
inOrder.verify(mockList).add("first");
inOrder.verify(mockList2).add("second");
```

## Fortgeschrittene Konzepte

### Argument Matchers

```java
// Beliebiges Argument
when(mockList.get(anyInt())).thenReturn("element");

// Spezielle Matcher
when(mockList.contains(argThat(new ArgumentMatcher<String>() {
    @Override
    public boolean matches(String s) {
        return s.startsWith("test");
    }
}))).thenReturn(true);

// Alternative mit Lambda
when(mockList.contains(argThat(s -> s.startsWith("test")))).thenReturn(true);
```

### Spy

```java
List<String> spyList = spy(new ArrayList<>());

// Teilweise echtes Verhalten
doReturn("real").when(spyList).get(0);

// Methoden aufrufen, die das echte Verhalten nutzen
spyList.add("element");
```

### Captor

```java
@Captor
private ArgumentCaptor<Person> captor;

@BeforeEach
void init() {
    MockitoAnnotations.openMocks(this);
}

@Test
void test() {
    service.addPerson(new Person("John", 30));
    verify(service).addPerson(captor.capture());
    
    Person captured = captor.getValue();
    assertEquals("John", captured.getName());
}
```

### ArgumentCaptor (Alternative)

```java
ArgumentCaptor<Person> captor = ArgumentCaptor.forClass(Person.class);
verify(service).addPerson(captor.capture());
```

## Annotationen

### @Mock

```java
class MyTest {
    @Mock
    private List<String> mockList;
    
    @BeforeEach
    void init() {
        MockitoAnnotations.openMocks(this);
    }
}
```

### @Spy

```java
class MyTest {
    @Spy
    private List<String> spyList = new ArrayList<>();
}
```

### @InjectMocks

```java
class MyTest {
    @Mock
    private Dependency dependency;
    
    @InjectMocks
    private Service service;
}
```

## Best Practices

1. **Schnittstellen mocken** - Mocken Sie immer Schnittstellen, nicht konkrete Klassen
2. **Keine echten Objekte** - Verwandeln Sie keine echten Objekte in Mocks
3. **Naming** - Verwenden Sie aussagekräftige Namen für Mocks
4. **Verification** - Verwenden Sie Verification nur wenn nötig
5. **Reset** - Vermeiden Sie `reset()` - es deutet auf schlechtes Testdesign hin

## Häufige Szenarien

### Datenbank-Mocking

```java
@Mock
private UserRepository userRepository;

@Test
void testUserCreation() {
    User user = new User("test@test.com");
    when(userRepository.save(any(User.class))).thenReturn(user);
    
    User result = userService.createUser("test@test.com");
    
    assertNotNull(result);
    verify(userRepository).save(any(User.class));
}
```

### Exception-Testing

```java
@Test
void testException() {
    when(service.getUser(1)).thenThrow(new UserNotFoundException("Not found"));
    
    assertThrows(UserNotFoundException.class, () -> {
        service.getUser(1);
    });
}
```

### Void-Methoden

```java
@Test
void testVoidMethod() {
    doNothing().when(mockList).clear();
    doThrow(new RuntimeException()).when(mockList).add(any());
}
```

## Ressourcen

- Offizielle Website: https://site.mockito.org
- GitHub: https://github.com/mockito/mockito
- Javadoc: https://javadoc.io/doc/org.mockito/mockito-core

## Lizenz

MIT License
