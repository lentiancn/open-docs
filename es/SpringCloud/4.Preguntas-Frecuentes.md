# Spring Cloud Preguntas Frecuentes

## Preguntas Generales

### ¿Qué es Spring Cloud?
Spring Cloud es un framework para construir sistemas distribuidos cloud-native. Proporciona herramientas para service discovery, gestión de configuración, circuit breakers, API gateways y otros patrones cloud-native.

### ¿Cuál es la diferencia entre Spring Boot y Spring Cloud?
Spring Boot es para construir aplicaciones individuales. Spring Cloud coordina múltiples servicios para crear un sistema distribuidos.

### ¿Spring Cloud es solo para microservicios?
Aunque principalmente usado para microservicios, Spring Cloud también puede usarse para:
- Aplicaciones monolíticas con características cloud
- Arquitecturas serverless
- Sistemas impulsados por eventos

## Preguntas de Instalación

### ¿Cómo agrego Spring Cloud a mi proyecto?
Agrega el BOM de Spring Cloud y dependencias:

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### ¿Qué versión de Spring Cloud debo usar?
- Spring Boot 2.7.x → Spring Cloud 2022.0.x
- Spring Boot 2.6.x → Spring Cloud 2021.0.x
- Spring Boot 2.5.x → Spring Cloud 2020.0.x

## Preguntas de Service Discovery

### ¿Cómo funciona Eureka?
1. Los servicios se registran con Eureka al iniciar
2. Los clientes consultan Eureka para encontrar ubicaciones de servicios
3. Eureka maneja heartbeats para detectar instancias saludables
4. Las instancias fallidas se eliminan automáticamente

### ¿Cómo registro un servicio?
```java
@SpringBootApplication
@EnableEurekaClient
public class MiServicioApplication {
    public static void main(String[] args) {
        SpringApplication.run(MiServicioApplication.class, args);
    }
}
```

### ¿Cómo descubro servicios?
```java
@RestController
public class MiController {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    @GetMapping("/instancias/{appName}")
    public List<ServiceInstance> instancias(@PathVariable String appName) {
        return discoveryClient.getInstances(appName);
    }
}
```

## Preguntas de Configuration

### ¿Cómo funciona Spring Cloud Config?
```yaml
# Config Server - application.yml
spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: https://github.com/myorg/config-repo
```

### ¿Cómo usan los clientes el config server?
```yaml
# Client - bootstrap.yml
spring:
  application:
    name: miapp
  cloud:
    config:
      uri: http://localhost:8888
```

### ¿Cómo actualizo la configuración en runtime?
Usa el endpoint `/actuator/refresh`:
```bash
curl -X POST http://localhost:8080/actuator/refresh
```

## Preguntas de Circuit Breaker

### ¿Cómo uso Resilience4j?
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
```

```java
@Service
public class MiServicio {
    
    @CircuitBreaker(name = "miServicio", fallbackMethod = "fallback")
    public String llamarServicio() {
        // Llamar servicio externo
    }
    
    public String fallback(Exception e) {
        return "Respuesta fallback";
    }
}
```

### ¿Cuál es la diferencia entre Hystrix y Resilience4j?
| Característica | Hystrix | Resilience4j |
|----------------|---------|--------------|
| Mantenimiento | Descontinuado | Activo |
| API | Basado en anotaciones | Funcional |
| Reactivo | Limitado | Soporte completo |

## Solución de Problemas

### Los servicios no se encuentran
- Verificar registro en Eureka
- Verificar conectividad de red
- Asegurar nombres de servicios correctos

### Configuración no carga
- Verificar que config server esté corriendo
- Verificar configuración de repositorio git
- Asegurar que nombre de aplicación coincida

### Circuit breaker abierto
- Verificar método fallback
- Revisar configuraciones de timeout
- Revisar salud del servicio externo

## Mejores Prácticas

1. Usa Spring Cloud Contract para testing de APIs
2. Implementa manejo de errores apropiado
3. Implementa distributed tracing
4. Configura health checks
5. Usa config server para todas las configuraciones
6. Implementa circuit breakers para llamadas externas

## Recursos

- Documentación Oficial: https://docs.spring.io/spring-cloud/docs/current/reference/html
- Spring Cloud Netflix: https://cloud.spring.io/spring-cloud-netflix
- Spring Cloud Gateway: https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html
