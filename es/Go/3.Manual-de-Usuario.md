# Manual de Usuario de Go

> Guía completa para programar en Go

---

## Inicio Rápido

### Primer Programa en Go

```go
package main

import "fmt"

func main() {
    fmt.Println("¡Hola, Mundo!")
}
```

Ejecutar el programa:

```go run main.go
```

---

## Sintaxis Básica

### Declaración de Variables

```go
// Método 1: Inferencia de tipo
var nombre = "Go"

// Método 2: Tipo explícito
var edad int = 10

// Método 3: Declaración corta (dentro de funciones)
mensaje := "Hola"
```

### Tipos de Datos

```go
// Enteros
var i int = 10
var ui uint = 10

// Números decimales
var f float64 = 3.14

// Cadenas
var s string = "Hola"

// Booleanos
var b bool = true

// Arrays
var arr [5]int = [5]int{1, 2, 3, 4, 5}

// Slices
slice := []int{1, 2, 3}

// Maps
m := map[string]int{"a": 1, "b": 2}
```

### Control de Flujo

```go
// Sentencia if
if x > 10 {
    fmt.Println("Mayor que 10")
} else {
    fmt.Println("Menor o igual a 10")
}

// Bucle for
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// Sentencia switch
switch dia {
case 1:
    fmt.Println("Lunes")
default:
    fmt.Println("Otro")
}
```

---

## Funciones

### Definición de Funciones

```go
// Función básica
func sumar(a, b int) int {
    return a + b
}

// Múltiples valores de retorno
func dividir(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("división por cero")
    }
    return a / b, nil
}

// Valores de retorno nombrados
func partir(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}
```

### Funciones Variádicas

```go
func sumar(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}

// Uso
sumar(1, 2, 3, 4, 5)
```

---

## Estructuras y Métodos

### Definición de Estructuras

```go
type Persona struct {
    Nombre string
    Edad   int
}

// Método
func (p Persona) Saludar() {
    fmt.Printf("Hola, soy %s\n", p.Nombre)
}
```

### Interfaces

```go
type Escritor interface {
    Escribir([]byte) (int, error)
}

type Lector interface {
    Leer([]byte) (int, error)
}
```

---

## Concurrencia

### Goroutines

```go
// Iniciar una goroutine
go func() {
    fmt.Println("Hola desde goroutine")
}()

// Con argumentos
go func(msg string) {
    fmt.Println(msg)
}("Hola")
```

### Canales

```go
// Crear canal
ch := make(chan int)

// Enviar datos
ch <- 10

// Recibir datos
valor := <-ch

// Canal con buffer
buffered := make(chan int, 10)
```

### Select

```go
select {
case msg := <-ch1:
    fmt.Println("Recibido:", msg)
case msg := <-ch2:
    fmt.Println("Recibido:", msg)
case <-time.After(time.Second):
    fmt.Println("Tiempo de espera agotado")
}
```

---

## Manejo de Errores

### Definición de Errores

```go
import "errors"

func dividir(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("división por cero")
    }
    return a / b, nil
}
```

### Verificación de Errores

```go
resultado, err := dividir(10, 0)
if err != nil {
    fmt.Println("Error:", err)
    return
}
fmt.Println("Resultado:", resultado)
```

---

## Gestión de Paquetes

### Inicializar Módulo

```bash
go mod init github.com/usuario/proyecto
```

### Añadir Dependencias

```bash
go get github.com/paquete/nombre
```

### Organizar Dependencias

```bash
go mod tidy
```

---

## Pruebas

### Pruebas Unitarias

```go
package main

import "testing"

func TestSumar(t *testing.T) {
    resultado := sumar(2, 3)
    if resultado != 5 {
        t.Errorf("Esperado 5, obtenido %d", resultado)
    }
}
```

Ejecutar pruebas:

```bash
go test ./...
```

### Pruebas de Rendimiento

```go
func BenchmarkHola(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Hola()
    }
}
```

Ejecutar benchmarks:

```bash
go test -bench=.
```

---

## Mejores Prácticas

1. Usar Go Modules para gestión de dependencias
2. Seguir convenciones de código Go (ejecutar `go fmt`)
3. Preferir canales para comunicación concurrida
4. Evitar variables globales
5. Escribir pruebas unitarias
6. Manejar errores promptly
7. Usar `context` para gestión del ciclo de vida de solicitudes
