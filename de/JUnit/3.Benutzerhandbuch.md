# JUnit 5 Benutzerhandbuch

## Erste Schritte mit JUnit 5

### Grundlegender Test

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class MyFirstTest {
    
    @Test
    void simpleTest() {
        assertEquals(2, 1 + 1);
    }
}
```

## Test-Lebenszyklus

###Vor- und Nachbereitung

```java
class LifecycleTest {
    
    @BeforeAll
    static void beforeAll() {
        // Wird einmal vor allen Tests ausgeführt
    }
    
    @AfterAll
    static void afterAll() {
        // Wird einmal nach allen Tests ausgeführt
    }
    
    @BeforeEach
    void beforeEach() {
        // Wird vor jedem Test ausgeführt
    }
    
    @AfterEach
    void afterEach() {
        // Wird nach jedem Test ausgeführt
    }
    
    @Test
    void testMethod() {
        // Testmethode
    }
}
```

## Assertions

### Grundlegende Assertions

```java
@Test
void basicAssertions() {
    assertEquals(4, 2 + 2);
    assertTrue(5 > 3);
    assertFalse(2 > 5);
    assertNull(null);
    assertNotNull("Hello");
}
```

### Exception-Tests

```java
@Test
void exceptionTest() {
    assertThrows(IllegalArgumentException.class, 
        () -> { throw new IllegalArgumentException("Fehler"); });
}
```

### Timeout-Tests

```java
@Test
void timeoutTest() {
    assertTimeout(Duration.ofSeconds(1), 
        () -> { /* code */ });
}
```

## Anzeigenamen

```java
@Test
@DisplayName("Ein einfacher Mathe-Test")
void testAddition() {
    assertEquals(4, 2 + 2);
}
```

## Verschachtelte Tests

```java
class NestedTests {
    
    @Nested
    class AdditionTests {
        @Test
        void positiveZahlen() {
            assertEquals(5, 2 + 3);
        }
    }
    
    @Nested
    class SubtraktionTests {
        @Test
        void positivesErgebnis() {
            assertEquals(1, 3 - 2);
        }
    }
}
```

## Parametrisierte Tests

### Mit @ValueSource

```java
@ParameterizedTest
@ValueSource(ints = {1, 2, 3, 4, 5})
void testIstPositiv(int Zahl) {
    assertTrue(Zahl > 0);
}
```

### Mit @CsvSource

```java
@ParameterizedTest
@CsvSource({"1, 1", "2, 4", "3, 9"})
void testQuadrat(int input, int expected) {
    assertEquals(expected, input * input);
}
```

### Mit @MethodSource

```java
@ParameterizedTest
@MethodSource("lieferDaten")
void testMitMethode(String arg) {
    assertNotNull(arg);
}

static Stream<String> lieferDaten() {
    return Stream.of("Apple", "Banana", "Cherry");
}
```

## Wiederholte Tests

```java
@RepeatedTest(5)
@DisplayName("Test wird 5mal wiederholt")
void repeatedTest(TestInfo testInfo) {
    System.out.println("Wiederholung #" + 
        testInfo.getDisplayName());
    assertEquals(4, 2 + 2);
}
```

## Dynamische Tests

```java
@TestFactory
Stream<DynamicTest> dynamicTests() {
    return Stream.of("Hello", "World")
        .map(text -> DynamicTest.dynamicTest(
            "Test: " + text,
            () -> assertNotNull(text)
        ));
}
```

## Tagging und Filterung

```java
@Tag("langsam")
@Tag("integration")
@Test
void langsamerTest() {
    // Test-Implementierung
}
```

Filter in build.gradle:

```groovy
test {
    useJUnitPlatform()
    filter {
        includeTestsMatching "*Integration*"
        excludeTestsMatching "*LangSam*"
    }
}
```

## Bedingte Testausführung

```java
@EnabledOnOs(OS.WINDOWS)
@Test
void nurWindows() {
    // Wird nur auf Windows ausgeführt
}

@EnabledOnJre(JRE.JAVA_8, JRE.JAVA_9)
@Test
void java8Oder9() {
    // Wird nur auf Java 8 oder 9 ausgeführt
}
```

## Erweiterungen (Extensions)

### Eigene Extension erstellen

```java
public class MyExtension implements BeforeEachCallback {
    
    @Override
    void beforeEach(ExtensionContext context) {
        // Code vor jedem Test
    }
}
```

### Extension verwenden

```java
@ExtendWith(MyExtension.class)
class MyTest {
    @Test
    void test() {
        // Test
    }
}
```

## Test-Injection

```java
@Test
void testMitParameter(TestInfo testInfo) {
    System.out.println("Test: " + testInfo.getDisplayName());
}
```

## Best Practices

1. **Klare Namen**: Verwenden Sie @DisplayName für beschreibende Namen
2. **Eine Behauptung pro Test**: Besser mehrere kleine Tests als ein großer
3. **Unabhängige Tests**: Tests sollten nicht voneinander abhängen
4. **Aussagekräftige Fehlermeldungen**: Fügen Sie benutzerdefinierte Nachrichten hinzu
5. **Testorganisation**: Verwenden Sie verschachtelte Klassen und Tags
6. **Parametrisierte Tests**: Reduzieren Sie Code-Duplikation
