# Go ユーザーマニアル

> Goプログラミングの完全なガイド

---

## クイックスタート

### 最初のGoプログラム

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

プログラムを実行：

```bash
go run main.go
```

---

## 基本的な構文

### 変数宣言

```go
// 方法1：型推論
var name = "Go"

// 方法2：明示的な型
var age int = 10

// 方法3：短い変数宣言（関数内）
message := "Hello"
```

### データ型

```go
// 整数
var i int = 10
var ui uint = 10

// 浮動小数点数
var f float64 = 3.14

// 文字列
var s string = "Hello"

// ブール値
var b bool = true

// 配列
var arr [5]int = [5]int{1, 2, 3, 4, 5}

// スライス
slice := []int{1, 2, 3}

// マップ
m := map[string]int{"a": 1, "b": 2}
```

### 制御フロー

```go
// if文
if x > 10 {
    fmt.Println("10より大きい")
} else {
    fmt.Println("10以下")
}

// forループ
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// switch文
switch day {
case 1:
    fmt.Println("月曜日")
default:
    fmt.Println("その他")
}
```

---

## 関数

### 関数定義

```go
// 基本的な関数
func add(a, b int) int {
    return a + b
}

// 複数の戻り値
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("ゼロ除算")
    }
    return a / b, nil
}

// 名前付き戻り値
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}
```

### 可変長引数

```go
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}

// 使用例
sum(1, 2, 3, 4, 5)
```

---

## 構造体とメソッド

### 構造体定義

```go
type Person struct {
    Name string
    Age  int
}

// メソッド
func (p Person) SayHello() {
    fmt.Printf("こんにちは、%sです\n", p.Name)
}
```

### インターフェース

```go
type Writer interface {
    Write([]byte) (int, error)
}

type Reader interface {
    Read([]byte) (int, error)
}
```

---

## 並发プログラミング

### Goroutine

```go
// goroutineを開始
go func() {
    fmt.Println("Hello from goroutine")
}()

// 引数付き
go func(msg string) {
    fmt.Println(msg)
}("Hello")
```

### Channel

```go
// channelを作成
ch := make(chan int)

// データを送信
ch <- 10

// データを受信
value := <-ch

// バッファ付きchannel
buffered := make(chan int, 10)
```

### Select

```go
select {
case msg := <-ch1:
    fmt.Println("受信:", msg)
case msg := <-ch2:
    fmt.Println("受信:", msg)
case <-time.After(time.Second):
    fmt.Println("タイムアウト")
}
```

---

## エラー処理

### エラー定義

```go
import "errors"

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("ゼロ除算")
    }
    return a / b, nil
}
```

### エラーチェック

```go
result, err := divide(10, 0)
if err != nil {
    fmt.Println("エラー:", err)
    return
}
fmt.Println("結果:", result)
```

---

## パッケージ管理

### モジュールの初期化

```bash
go mod init github.com/username/project
```

### 依存関係を追加

```go get github.com/package/name
```

### 依存関係の整理

```bash
go mod tidy
```

---

## テスト

### ユニットテスト

```go
package main

import "testing"

func TestAdd(t *testing.T) {
    result := add(2, 3)
    if result != 5 {
        t.Errorf("期待値 5, 実際 %d", result)
    }
}
```

テストを実行：

```bash
go test ./...
```

### ベンチマークテスト

```go
func BenchmarkHello(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Hello()
    }
}
```

ベンチマークを実行：

```bash
go test -bench=.
```

---

## ベストプラクティス

1. 依存関係管理にGo Moduleを使用
2. Goコード規則に従う（`go fmt`を実行）
3. 並发通信にはchannelを優先
4. グローバル変数を避ける
5. ユニットテストを書く
6. エラーを適切に処理
7. `context`を使用してリクエストライフサイクルを管理
