# Go 语言使用手册

本手册将深入介绍 Go 语言的核心语法、特性以及实际开发中的最佳实践。

## 基础语法

### 变量声明

```go
// 方式1：指定类型
var name string = "Tom"

// 方式2：类型推断
var age = 25

// 方式3：短变量声明（函数内）
city := "Beijing"

// 多个变量
var (
    firstName = "John"
    lastName  = "Doe"
    height    = 180
)

// 常量
const Pi = 3.14159
const (
    StatusOK = 200
    StatusNotFound = 404
)
```

### 基本数据类型

```go
// 整数
var i int = 10
var i8 int8 = 10      // -128 ~ 127
var i16 int16 = 10   // -32768 ~ 32767
var i32 int32 = 10
var i64 int64 = 10

// 无符号整数
var u uint = 10
var u8 uint8 = 10    // 0 ~ 255
var u16 uint16 = 10
var u32 uint32 = 10
var u64 uint64 = 10

// 浮点数
var f32 float32 = 3.14
var f64 float64 = 3.1415926

// 复数
var c complex64 = complex(1, 2)  // 1+2i
var c128 complex128 = complex(1, 2)

// 字符串
var s string = "Hello, World!"

// 布尔值
var b bool = true

// 字节切片
var bytes []byte = []byte("hello")
```

### 运算符

```go
// 算术运算符
+ - * / %

// 比较运算符
== != < > <= >=

// 逻辑运算符
&& || !

// 位运算符
& | ^ << >>
```

### 流程控制

```go
// if-else
if age >= 18 {
    fmt.Println("成年人")
} else if age >= 6 {
    fmt.Println("未成年人")
} else {
    fmt.Println("儿童")
}

// switch
switch day := time.Now().Weekday(); day {
case time.Saturday, time.Sunday:
    fmt.Println("周末")
default:
    fmt.Println("工作日")
}

// for 循环
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// 死循环
for {
    // 无限循环，需要 break 退出
    break
}

// for-range 遍历
nums := []int{1, 2, 3, 4, 5}
for index, value := range nums {
    fmt.Println(index, value)
}

// 遍历字符串
str := "Hello"
for i, c := range str {
    fmt.Printf("%d: %c\n", i, c)
}

// 跳过迭代
for i := 0; i < 10; i++ {
    if i % 2 == 0 {
        continue  // 跳过偶数
    }
    fmt.Println(i)
}
```

## 函数

### 函数定义

```go
// 基础函数
func greet(name string) string {
    return "Hello, " + name
}

// 多返回值
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// 命名返回值
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return  // 隐式返回命名值
}

// 可变参数
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}

// 函数作为参数
func apply(n int, fn func(int) int) int {
    return fn(n)
}

// 函数作为返回值
func makeAdder(n int) func(int) int {
    return func(x int) int {
        return x + n
    }
}
```

### 错误处理

```go
// 定义错误
var ErrNotFound = errors.New("not found")

// 使用错误
func findUser(id int) (*User, error) {
    // 查找用户逻辑
    if id <= 0 {
        return nil, fmt.Errorf("invalid id: %d", id)
    }
    return &User{ID: id, Name: "Tom"}, nil
}

// 处理错误
user, err := findUser(1)
if err != nil {
    log.Fatal(err)
}
fmt.Println(user.Name)

// defer 延迟执行
func readFile(filename string) {
    file, err := os.Open(filename)
    if err != nil {
        log.Fatal(err)
    }
    defer file.Close()  // 函数结束前执行
    // 读取文件...
}

// panic 和 recover
func safeCall() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered:", r)
        }
    }()
    panic("something went wrong")
}
```

## 数据结构

### 数组和切片

```go
// 数组（固定长度）
var arr [5]int = [5]int{1, 2, 3, 4, 5}

// 切片（动态数组）
slice := []int{1, 2, 3, 4, 5}

// 使用 make 创建切片
s := make([]int, 5, 10)  // 长度5，容量10

// 切片操作
slice = append(slice, 6)       // 添加元素
slice = slice[1:3]            // 切片
slice = make([]int, len(slice)) // 复制

// 遍历切片
for i, v := range slice {
    fmt.Println(i, v)
}
```

### Map（字典）

```go
// 创建 Map
m := make(map[string]int)

// 添加元素
m["apple"] = 1
m["banana"] = 2

// 读取值
count, ok := m["apple"]  // ok 为 false 表示不存在

// 删除元素
delete(m, "apple")

// 遍历 Map
for key, value := range m {
    fmt.Println(key, value)
}

// Map 字面量
colors := map[string]string{
    "red":   "#FF0000",
    "green": "#00FF00",
    "blue":  "#0000FF",
}
```

### 结构体

```go
// 定义结构体
type User struct {
    ID        int
    Name      string
    Email     string
    Age       int
    CreatedAt time.Time
}

// 创建结构体实例
user := User{
    ID:   1,
    Name: "Tom",
}

// 访问字段
fmt.Println(user.Name)

// 指针
userPtr := &user
fmt.Println(userPtr.Name)  // 自动解引用

// 结构体方法（值接收者）
func (u User) SayHello() string {
    return "Hello, " + u.Name
}

// 结构体方法（指针接收者）
func (u *User) SetName(name string) {
    u.Name = name
}

// 嵌入（类似继承）
type Employee struct {
    User
    Department string
}
```

### 接口

```go
// 定义接口
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// 接口组合
type ReadWriter interface {
    Reader
    Writer
}

// 空接口（可接受任何类型）
func printAny(v interface{}) {
    fmt.Println(v)
}

// 类型断言
var i interface{} = "hello"
s, ok := i.(string)
if ok {
    fmt.Println(s)
}

// 类型 switch
func getType(v interface{}) string {
    switch v.(type) {
    case int:
        return "int"
    case string:
        return "string"
    case bool:
        return "bool"
    default:
        return "unknown"
    }
}
```

## 并发编程

### Goroutine（协程）

```go
// 启动协程
go func() {
    fmt.Println("Hello from goroutine!")
}()

// 带参数的协程
go func(msg string) {
    fmt.Println(msg)
}("Hello")

// 使用 channel 通信
ch := make(chan string)
go func() {
    ch <- "message"
}()
msg := <-ch
```

### Channel（通道）

```go
// 创建通道
ch := make(chan int)

// 创建带缓冲的通道
bufferedCh := make(chan int, 10)

// 发送数据
ch <- 10

// 接收数据
value := <-ch

// 关闭通道
close(ch)

// 通道方向
func sendOnly(ch chan<- int) {}  // 只能发送
func recvOnly(ch <-chan int) {}  // 只能接收
```

### Select 语句

```go
select {
case msg := <-ch1:
    fmt.Println("Received:", msg)
case msg := <-ch2:
    fmt.Println("Received:", msg)
case <-time.After(time.Second):
    fmt.Println("Timeout")
default:
    fmt.Println("No message")
}
```

### WaitGroup

```go
import "sync"

var wg sync.WaitGroup

func worker(id int) {
    defer wg.Done()
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d done\n", id)
}

func main() {
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go worker(i)
    }
    wg.Wait()
}
```

### Mutex（互斥锁）

```go
import "sync"

type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}
```

### Context

```go
import "context"

func longRunningTask(ctx context.Context) {
    select {
    case <-time.After(2 * time.Second):
        fmt.Println("Task completed")
    case <-ctx.Done():
        fmt.Println("Task cancelled:", ctx.Err())
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    go longRunningTask(ctx)
    
    time.Sleep(time.Second)
    cancel()  // 取消任务
    time.Sleep(time.Second)
}
```

## 错误处理和日志

### 错误包装

```go
import "fmt"

// 使用 fmt.Errorf 包装错误
if err != nil {
    return fmt.Errorf("failed to fetch user: %w", err)
}

// 使用 errors.Is 检查错误
if errors.Is(err, ErrNotFound) {
    // 处理未找到错误
}

// 使用 errors.As 检查错误类型
var parseErr *json.SyntaxError
if errors.As(err, &parseErr) {
    fmt.Println("JSON 语法错误在位置:", parseErr.Offset)
}
```

### 日志

```go
import "log"

// 基础日志
log.Println("Info message")
log.Printf("User %d created", userID)

// 定制日志
log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
log.SetPrefix("[APP] ")

// 错误日志
log.Fatal("Fatal error")   // 输出后 os.Exit(1)
log.Panic("Panic")         // 输出后 panic()
```

## 标准库常用示例

### 文件操作

```go
import (
    "io/ioutil"
    "os"
)

// 读取文件
data, err := ioutil.ReadFile("file.txt")
if err != nil {
    log.Fatal(err)
}

// 写入文件
err = ioutil.WriteFile("output.txt", []byte("content"), 0644)

// 使用 os 包
file, err := os.Open("file.txt")
if err != nil {
    log.Fatal(err)
}
defer file.Close()

buffer := make([]byte, 1024)
n, err := file.Read(buffer)
```

### HTTP 服务

```go
import (
    "net/http"
    "fmt"
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, %s!", r.URL.Path[1:])
}

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}
```

### JSON 处理

```go
import (
    "encoding/json"
    "fmt"
)

// 编码
type User struct {
    Name  string `json:"name"`
    Age   int    `json:"age"`
}

user := User{Name: "Tom", Age: 25}
data, err := json.Marshal(user)

// 解码
jsonStr := `{"name":"Tom","age":25}`
var user2 User
json.Unmarshal([]byte(jsonStr), &user2)
```

### 时间处理

```go
import (
    "time"
    "fmt"
)

// 当前时间
now := time.Now()

// 解析时间
t, _ := time.Parse("2006-01-02 15:04:05", "2024-01-01 10:00:00")

// 时间格式化
fmt.Println(now.Format("2006-01-02 15:04:05"))

// 时间计算
tomorrow := now.Add(24 * time.Hour)
diff := tomorrow.Sub(now)

// 定时器
timer := time.NewTimer(2 * time.Second)
<-timer.C
```

## 常用框架和库

### Web 框架

```go
// Gin（最流行）
import "github.com/gin-gonic/gin"

func main() {
    r := gin.Default()
    r.GET("/ping", func(c *gin.Context) {
        c.JSON(200, gin.H{"message": "pong"})
    })
    r.Run()
}

// Echo
import "github.com/labstack/echo/v4"

func main() {
    e := echo.New()
    e.GET("/ping", func(c echo.Context) error {
        return c.String(200, "pong")
    })
    e.Start(":8080")
}

// Fiber
import "github.com/gofiber/fiber/v2"

func main() {
    app := fiber.New()
    app.Get("/ping", func(c *fiber.Ctx) error {
        return c.SendString("pong")
    })
    app.Listen(":8080")
}
```

### 数据库

```go
// MySQL - 使用 go-sql-driver
import (
    "database/sql"
    _ "github.com/go-sql-driver/mysql"
)

db, _ := sql.Open("mysql", "user:password@/dbname")
rows, _ := db.Query("SELECT id, name FROM users")
defer rows.Close()

for rows.Next() {
    var id int
    var name string
    rows.Scan(&id, &name)
}

// Redis - 使用 go-redis
import "github.com/go-redis/redis/v8"

client := redis.NewClient(&redis.Options{
    Addr: "localhost:6379",
})

client.Set(ctx, "key", "value", 0)
result, _ := client.Get(ctx, "key").Result()
```

### 命令行

```go
// 使用 cobra
import "github.com/spf13/cobra"

var rootCmd = &cobra.Command{
    Use:   "app",
    Short: "My CLI app",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("Hello!")
    },
}

func main() {
    rootCmd.Execute()
}
```

## 测试

### 单元测试

```go
// math_test.go
package math

import "testing"

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("Add(2, 3) = %d; want 5", result)
    }
}

func TestMultiply(t *testing.T) {
    tests := []struct {
        a, b, want int
    }{
        {2, 3, 6},
        {0, 5, 0},
        {-2, 3, -6},
    }
    
    for _, tt := range tests {
        got := Multiply(tt.a, tt.b)
        if got != tt.want {
            t.Errorf("Multiply(%d, %d) = %d; want %d", tt.a, tt.b, got, tt.want)
        }
    }
}

// 运行测试
// go test -v ./...
// go test -cover ./...
```

### 基准测试

```go
func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(2, 3)
    }
}

// 运行基准测试
// go test -bench=. ./...
```

## 总结

本手册涵盖了 Go 语言的核心知识点：

- **基础语法**：变量、数据类型、流程控制
- **函数**：多返回值、错误处理、延迟执行
- **数据结构**：数组、切片、Map、结构体、接口
- **并发**：Goroutine、Channel、Select、Context
- **标准库**：文件、HTTP、JSON、时间
- **常用框架**：Gin、数据库、命令行
- **测试**：单元测试、基准测试

掌握这些内容后，你就可以开始构建各种 Go 应用了。建议结合实际项目不断深化理解。
