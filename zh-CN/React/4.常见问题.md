# React 常见问题

本章节汇总了 React 开发中的常见问题。

## 开发问题

### Q1: 组件不渲染

**解决方案：**
1. 检查组件是否正确导出
2. 检查 JSX 语法是否正确
3. 查看控制台错误信息

### Q2: 状态不更新

**解决方案：**
1. 确保使用 useState 返回的 setter
2. 状态更新是异步的，如果需要基于更新后的值：
   ```jsx
   // 错误
   setCount(count + 1);
   setCount(count + 1);
   
   // 正确
   setCount(prev => prev + 1);
   setCount(prev => prev + 1);
   ```

### Q3: 事件处理 this 丢失

**解决方案：**
```jsx
// 方式1：使用箭头函数
<button onClick={() => this.handleClick()}>点击</button>

// 方式2：使用 bind
<button onClick={this.handleClick.bind(this)}>点击</button>

// 方式3：在构造函数中绑定
constructor(props) {
  super(props);
  this.handleClick = this.handleClick.bind(this);
}

// 方式4：使用箭头函数属性（推荐）
handleClick = () => {
  console.log(this);
}
```

### Q4: 列表渲染缺少 key

**问题：** `Warning: Each child in a list should have a unique key prop`

**解决方案：**
```jsx
// 添加唯一的 key
{items.map(item => (
  <li key={item.id}>{item.name}</li>
))}
```

### Q5: 表单输入不更新

**问题：** 输入后显示的值不变

**解决方案：**
```jsx
// 受控组件需要同时设置 value 和 onChange
function Input() {
  const [value, setValue] = useState('');
  
  return (
    <input 
      value={value}                    // 必须
      onChange={e => setValue(e.target.value)}  // 必须
    />
  );
}
```

## Hooks 问题

### Q6: 无限循环

**问题：** useEffect 无限执行

**解决方案：**
```jsx
// 检查依赖数组
useEffect(() => {
  // 这个函数会无限执行
  setCount(count + 1);
}, [count]); // 每次 count 变化都会执行

// 解决：使用函数式更新
useEffect(() => {
  setCount(prev => prev + 1);
}, []); // 空数组，只执行一次
```

### Q7: useEffect 清理函数不执行

**解决方案：**
```jsx
useEffect(() => {
  const timer = setInterval(() => {
    console.log('tick');
  }, 1000);
  
  return () => {
    // 组件卸载时清理
    clearInterval(timer);
  };
}, []);
```

### Q8: Hooks 只能在顶层调用

**问题：** `Error: Hooks can only be called inside the body of a function component`

**解决方案：**
- 确保 Hooks 在函数组件的顶层调用
- 不要在循环、条件语句、嵌套函数中调用 Hooks

### Q9: useState 初始化只执行一次

**解决方案：**
```jsx
// useState 的参数只会在首次渲染时使用
const [state, setState] = useState(expensiveCalculation());

// 如果需要延迟初始化，使用函数
const [state, setState] = useState(() => {
  // 只执行一次
  return expensiveCalculation();
});
```

## 性能问题

### Q10: 组件重复渲染

**解决方案：**
1. 使用 React.memo
   ```jsx
   const MemoizedComponent = React.memo(function Component({ data }) {
     return <div>{data.name}</div>;
   });
   ```

2. 使用 useMemo
   ```jsx
   const expensive = useMemo(() => {
     return computeExpensiveValue(a, b);
   }, [a, b]);
   ```

3. 使用 useCallback
   ```jsx
   const handleClick = useCallback(() => {
     console.log(count);
   }, [count]);
   ```

### Q11: 虚拟 DOM 性能问题

**解决方案：**
1. 使用 key 时保持稳定
2. 避免在 JSX 中使用内联函数作为 prop
3. 使用 useMemo 和 useCallback 优化

### Q12: 内存泄漏

**解决方案：**
```jsx
useEffect(() => {
  const subscription = dataSource.subscribe();
  
  return () => {
    // 清理订阅
    subscription.unsubscribe();
  };
}, []);
```

## 路由问题

### Q13: 路由不跳转

**解决方案：**
1. 使用正确的跳转方式
   ```jsx
   import { useNavigate } from 'react-router-dom';
   
   function App() {
     const navigate = useNavigate();
     
     return <button onClick={() => navigate('/path')}>跳转</button>;
   }
   ```

2. 使用 Link 组件
   ```jsx
   import { Link } from 'react-router-dom';
   
   <Link to="/path">跳转</Link>
   ```

### Q14: 路由参数不更新

**解决方案：**
```jsx
import { useParams } from 'react-router-dom';

function User() {
  const { id } = useParams();
  
  // 当 URL 参数变化时，重新加载数据
  useEffect(() => {
    loadUser(id);
  }, [id]);
  
  return <div>用户: {id}</div>;
}
```

## 样式问题

### Q15: 样式不生效

**解决方案：**
1. 检查 CSS 文件是否正确导入
2. 使用 CSS Modules 时注意命名
3. 确保样式优先级足够高

### Q16: 动态样式

**解决方案：**
```jsx
function StyledBox({ isActive }) {
  const style = {
    backgroundColor: isActive ? 'blue' : 'gray',
    padding: '10px'
  };
  
  return <div style={style}>Box</div>;
}
```

## 状态管理问题

### Q17: 状态分散

**解决方案：**
1. 使用 Context
2. 使用状态管理库（Redux、Zustand）

### Q18: Redux 状态不更新

**解决方案：**
1. 确保使用正确的 reducer
2. 检查 dispatch 是否正确调用
3. 确保订阅了正确的 store

## 构建问题

### Q19: 构建后体积太大

**解决方案：**
1. 使用代码分割
   ```jsx
   const LazyComponent = lazy(() => import('./Component'));
   
   function App() {
     return (
       <Suspense fallback={<Loading />}>
         <LazyComponent />
       </Suspense>
     );
   }
   ```

2. 使用 Tree Shaking
3. 移除不必要的依赖

### Q20: 环境变量不生效

**解决方案：**
```bash
# .env.development
VITE_API_URL=http://localhost:3000

# .env.production
VITE_API_URL=https://api.example.com
```

```jsx
// 使用
console.log(import.meta.env.VITE_API_URL);
```

## 其他问题

### Q21: 组件卸载后继续执行

**解决方案：**
```jsx
useEffect(() => {
  let cancelled = false;
  
  async function fetchData() {
    const data = await api.getData();
    if (!cancelled) {
      setData(data);
    }
  }
  
  fetchData();
  
  return () => {
    cancelled = true;
  };
}, []);
```

### Q22: 依赖引用变化

**解决方案：**
```jsx
// 对象作为依赖
const options = { timeout: 1000 };

useEffect(() => {
  // 每次渲染 options 都是新对象，导致无限执行
}, [options]);

// 解决：使用 useMemo
const options = useMemo(() => ({ timeout: 1000 }), []);
```

### Q23: 异步渲染问题

**解决方案：**
```jsx
// 使用 async/await 时注意
useEffect(() => {
  async function fetchData() {
    try {
      const data = await api.getData();
      setData(data);
    } catch (error) {
      setError(error);
    }
  }
  
  fetchData();
}, []);
```

## 总结

本章节涵盖了 React 开发中的常见问题：

- **开发**：渲染、状态更新、事件处理
- **Hooks**：useEffect 循环、调用规则、初始化
- **性能**：重复渲染、内存泄漏
- **路由**：跳转、参数
- **样式**：动态样式、CSS Modules
- **构建**：体积优化、环境变量

如需更多信息，请参考官方文档：https://react.dev
