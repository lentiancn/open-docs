# Mockito FAQ

Häufig gestellte Fragen zu Mockito.

## Allgemeine Fragen

### Was ist Mockito?

Mockito ist ein Open-Source-Mocking-Framework für Java. Es ermöglicht das Erstellen und Konfigurieren von Mock-Objekten für Unit-Tests.

### Warum Mockito verwenden?

- Isoliertes Testen ohne externe Abhängigkeiten
- Verbessert die Testgeschwindigkeit
- Einfache und intuitive API
- Gut integriert mit JUnit

### Was ist der Unterschied zwischen Mock und Spy?

- **Mock** - Ein komplett künstliches Objekt, das Sie vollständig kontrollieren
- **Spy** - Ein teilweise echtes Objekt, bei dem Sie nur bestimmte Methoden überschreiben

## Technische Fragen

### Wie mocke ich eine finale Klasse?

Verwenden Sie `mockito-inline`:

```groovy
testImplementation 'org.mockito:mockito-inline:5.8.0'
```

### Wie mocke ich statische Methoden?

Mit Mockito 3.7+ können Sie statische Methoden mocken:

```java
try (MockedStatic<Utilities> mocked = Mockito.mockStatic(Utilities.class)) {
    mocked.when(Utilities::getName).thenReturn("mocked");
    // Ihr Testcode
}
```

### Wie mocke ich private Methoden?

Private Methoden sollten nicht gemockt werden. Überprüfen Sie Ihr Design - private Methoden sind Implementierungsdetails.

### Wie teste ich eine Klasse mit vielen Abhängigkeiten?

Verwenden Sie `@InjectMocks` und `@Mock`:

```java
@Mock
private DependencyA dependencyA;

@Mock
private DependencyB dependencyB;

@InjectMocks
private ServiceUnderTest service;

@Test
void test() {
    when(dependencyA.doSomething()).thenReturn("result");
    // Testcode
}
```

## Fehlerbehebung

### "Cannot mock/spy class" Fehler

**Ursache:** Die Klasse ist final oder hat finale Methoden.

**Lösung:**
- Verwenden Sie `mockito-inline`
- Mocken Sie eine Schnittstelle statt einer Klasse

### "Unnecessary stubbing" Warnung

**Ursache:** Ein Stub wurde nicht verwendet.

**Lösung:**
- Entfernen Sie den ungenutzten Stub
- Oder verwenden Sie `lenient()`:

```java
lenient().when(mock.method()).thenReturn("value");
```

### "NullPointerException" beim Mocking

**Ursache:** Das Objekt wurde nicht korrekt initialisiert.

**Lösung:**
- Verwenden Sie `MockitoAnnotations.openMocks(this)` in `@BeforeEach`
- Oder `@ExtendWith(MockitoExtension.class)`

### "VerificationMissing" Fehler

**Ursache:** Eine gemockte Methode wurde aufgerufen, aber nicht verifiziert.

**Lösung:**
- Fügen Sie eine `verify()`-Aufruf hinzu
- Oder verwenden Sie `lenient()` wenn keine Verifizierung nötig ist

## Performance

### Langsame Tests

**Tipps zur Optimierung:**
1. Verwenden Sie nur notwendige Mocks
2. Vermeiden Sie `reset()` - erstellen Sie stattdessen neue Mocks
3. Nutzen Sie `@Mock` statt `mock()` für bessere Performance

## Integration

### Mit JUnit 4

```java
@RunWith(MockitoJUnitRunner.class)
public class MyTest {
    @Mock
    private List mockList;
}
```

### Mit JUnit 5

```java
@ExtendWith(MockitoExtension.class)
public class MyTest {
    @Mock
    private List mockList;
}
```

### Mit TestNG

```java
@Listeners(MockitoTestNGListener.class)
public class MyTest {
    @Mock
    private List mockList;
}
```

## Fortgeschritten

### Wie erstelle ich einen Custom Answer?

```java
when(mock.method()).thenAnswer(invocation -> {
    String arg = invocation.getArgument(0);
    return "Processed: " + arg;
});
```

### Wie mocke ich void-Methoden mit Exceptions?

```java
doThrow(new RuntimeException()).when(mockList).clear();
```

### Wie überprüfe ich die Aufrufreihenfolge?

```java
InOrder inOrder = inOrder(mockA, mockB);
inOrder.verify(mockA).method1();
inOrder.verify(mockB).method2();
```

## Ressourcen

- Stack Overflow: https://stackoverflow.com/questions/tagged/mockito
- GitHub Issues: https://github.com/mockito/mockito/issues

## Lizenz

MIT License
