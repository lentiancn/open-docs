# Go Handbuch

> Vollständige Anleitung zur Go-Programmierung

---

## Schnellstart

### Erstes Go-Programm

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

Programm ausführen:

```bash
go run main.go
```

---

## Grundlegende Syntax

### Variablendeklaration

```go
// Methode 1: Typinferenz
var name = "Go"

// Methode 2: Expliziter Typ
var age int = 10

// Methode 3: Kurze Variablendeklaration (innerhalb von Funktionen)
message := "Hello"
```

### Datentypen

```go
// Ganzzahlen
var i int = 10
var ui uint = 10

// Gleitkommazahlen
var f float64 = 3.14

// Zeichenketten
var s string = "Hello"

// Boolesche Werte
var b bool = true

// Arrays
var arr [5]int = [5]int{1, 2, 3, 4, 5}

// Slices
slice := []int{1, 2, 3}

// Maps
m := map[string]int{"a": 1, "b": 2}
```

### Kontrollstrukturen

```go
// if-Bedingung
if x > 10 {
    fmt.Println("Größer als 10")
} else {
    fmt.Println("Kleiner oder gleich 10")
}

// for-Schleife
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// switch
switch day {
case 1:
    fmt.Println("Montag")
default:
    fmt.Println("Andere")
}
```

---

## Funktionen

### Funktionsdefinition

```go
// Grundlegende Funktion
func add(a, b int) int {
    return a + b
}

// Mehrfache Rückgabewerte
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("Division durch Null")
    }
    return a / b, nil
}

// Benannte Rückgabewerte
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}
```

### Variable Argumente

```go
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}

// Verwenden
sum(1, 2, 3, 4, 5)
```

---

## Strukturen und Methoden

### Strukturdefinition

```go
type Person struct {
    Name string
    Age  int
}

// Methode
func (p Person) SayHello() {
    fmt.Printf("Hello, I'm %s\n", p.Name)
}
```

### Schnittstellen

```go
type Writer interface {
    Write([]byte) (int, error)
}

type Reader interface {
    Read([]byte) (int, error)
}
```

---

## Parallelität

### Goroutinen

```go
// Goroutine starten
go func() {
    fmt.Println("Hello from goroutine")
}()

// Mit Argumenten
go func(msg string) {
    fmt.Println(msg)
}("Hello")
```

### Channels

```go
// Channel erstellen
ch := make(chan int)

// Daten senden
ch <- 10

// Daten empfangen
value := <-ch

// Gepufferte Channels
buffered := make(chan int, 10)
```

### Select

```go
select {
case msg := <-ch1:
    fmt.Println("Empfangen:", msg)
case msg := <-ch2:
    fmt.Println("Empfangen:", msg)
case <-time.After(time.Second):
    fmt.Println("Zeitüberschreitung")
}
```

---

## Fehlerbehandlung

### Fehlerdefinition

```go
import "errors"

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("Division durch Null")
    }
    return a / b, nil
}
```

### Fehlerprüfung

```go
result, err := divide(10, 0)
if err != nil {
    fmt.Println("Fehler:", err)
    return
}
fmt.Println("Ergebnis:", result)
```

---

## Paketverwaltung

### Modul initialisieren

```bash
go mod init github.com/username/project
```

### Abhängigkeiten hinzufügen

```bash
go get github.com/paket/name
```

### Abhängigkeiten bereinigen

```bash
go mod tidy
```

---

## Tests

### Unit-Tests

```go
package main

import "testing"

func TestAdd(t *testing.T) {
    result := add(2, 3)
    if result != 5 {
        t.Errorf("Erwartet 5, bekommen %d", result)
    }
}
```

Tests ausführen:

```bash
go test ./...
```

### Benchmark-Tests

```go
func BenchmarkHello(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Hello()
    }
}
```

Benchmark ausführen:

```bash
go test -bench=.
```

---

## Best Practices

1. Go Module zur Abhängigkeitsverwaltung verwenden
2. Go-Codekonventionen folgen (go fmt ausführen)
3. Channels für Parallelität bevorzugen
4. Globale Variablen vermeiden
5. Unit-Tests schreiben
6. Fehler sofort behandeln
7. context zur Verwaltung von Anfragen verwenden
