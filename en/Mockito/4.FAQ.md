# Mockito FAQ

Frequently asked questions about Mockito.

## General Questions

### What is Mockito?

Mockito is an open-source mocking framework for Java. It allows creating and configuring mock objects for unit tests.

### Why use Mockito?

- Isolated testing without external dependencies
- Faster test execution
- Simple and intuitive API
- Well integrated with JUnit

### What is the difference between Mock and Spy?

- **Mock** - A completely artificial object that you fully control
- **Spy** - A partially real object where you only override specific methods

## Technical Questions

### How to mock a final class?

Use `mockito-inline`:

```groovy
testImplementation 'org.mockito:mockito-inline:5.8.0'
```

### How to mock static methods?

With Mockito 3.7+, you can mock static methods:

```java
try (MockedStatic<Utilities> mocked = Mockito.mockStatic(Utilities.class)) {
    mocked.when(Utilities::getName).thenReturn("mocked");
    // Your test code
}
```

### How to mock private methods?

Private methods should not be mocked. Check your design - private methods are implementation details.

### How to test a class with many dependencies?

Use `@InjectMocks` and `@Mock`:

```java
@Mock
private DependencyA dependencyA;

@Mock
private DependencyB dependencyB;

@InjectMocks
private ServiceUnderTest service;

@Test
void test() {
    when(dependencyA.doSomething()).thenReturn("result");
    // Test code
}
```

## Troubleshooting

### "Cannot mock/spy class" Error

**Cause:** The class is final or has final methods.

**Solution:**
- Use `mockito-inline`
- Mock an interface instead of a class

### "Unnecessary stubbing" Warning

**Cause:** A stub was not used.

**Solution:**
- Remove the unused stub
- Or use `lenient()`:

```java
lenient().when(mock.method()).thenReturn("value");
```

### "NullPointerException" when mocking

**Cause:** The object was not properly initialized.

**Solution:**
- Use `MockitoAnnotations.openMocks(this)` in `@BeforeEach`
- Or use `@ExtendWith(MockitoExtension.class)`

### "VerificationMissing" Error

**Cause:** A mocked method was called but not verified.

**Solution:**
- Add a `verify()` call
- Or use `lenient()` when verification is not needed

## Performance

### Slow Tests

**Optimization tips:**
1. Use only necessary mocks
2. Avoid `reset()` - create new mocks instead
3. Use `@Mock` instead of `mock()` for better performance

## Integration

### With JUnit 4

```java
@RunWith(MockitoJUnitRunner.class)
public class MyTest {
    @Mock
    private List mockList;
}
```

### With JUnit 5

```java
@ExtendWith(MockitoExtension.class)
public class MyTest {
    @Mock
    private List mockList;
}
```

### With TestNG

```java
@Listeners(MockitoTestNGListener.class)
public class MyTest {
    @Mock
    private List mockList;
}
```

## Advanced

### How to create a custom Answer?

```java
when(mock.method()).thenAnswer(invocation -> {
    String arg = invocation.getArgument(0);
    return "Processed: " + arg;
});
```

### How to mock void methods with exceptions?

```java
doThrow(new RuntimeException()).when(mockList).clear();
```

### How to verify call order?

```java
InOrder inOrder = inOrder(mockA, mockB);
inOrder.verify(mockA).method1();
inOrder.verify(mockB).method2();
```

## Resources

- Stack Overflow: https://stackoverflow.com/questions/tagged/mockito
- GitHub Issues: https://github.com/mockito/mockito/issues

## License

MIT License
