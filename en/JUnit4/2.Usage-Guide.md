# JUnit 4 Usage Guide

Comprehensive guide for using JUnit 4 effectively.

---

## Basic Test

### Simple Test Class

```java
import org.junit.Test;
import static org.junit.Assert.*;

public class CalculatorTest {

    @Test
    public void testAdd() {
        Calculator calc = new Calculator();
        assertEquals(5, calc.add(2, 3));
    }
}
```

---

## Annotations

### @Test

```java
@Test
public void testMethod() {
    // Test code
}
```

### @Before

```java
@Before
public void setUp() {
    // Runs before each test method
}
```

### @After

```java
@After
public void tearDown() {
    // Runs after each test method
}
```

### @BeforeClass

```java
@BeforeClass
public static void setUpClass() {
    // Runs once before all tests (must be static)
}
```

### @AfterClass

```java
@AfterClass
public static void tearDownClass() {
    // Runs once after all tests (must be static)
}
```

### @Ignore

```java
@Ignore("Not implemented yet")
@Test
public void testPending() {
    // Will be skipped
}
```

---

## Assertions

### assertEquals

```java
assertEquals(expected, actual);
assertEquals("Message", expected, actual);
```

### assertTrue / assertFalse

```java
assertTrue(condition);
assertFalse(condition);
```

### assertNull / assertNotNull

```java
assertNull(object);
assertNotNull(object);
```

### assertSame / assertNotSame

```java
assertSame(expected, actual);
assertNotSame(expected, actual);
```

### assertArrayEquals

```java
assertArrayEquals(expectedArray, actualArray);
```

### assertThat (with Matchers)

```java
import static org.hamcrest.Matchers.*;

assertThat(value, is(5));
assertThat(value, greaterThan(3));
assertThat(list, hasSize(5));
```

---

## Test Execution

### Run with JUnitCore

```java
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
    public static void main(String[] args) {
        Result result = JUnitCore.runClasses(CalculatorTest.class);
        
        for (Failure failure : result.getFailures()) {
            System.out.println(failure.toString());
        }
        
        System.out.println("Tests run: " + result.getRunCount());
        System.out.println("Failures: " + result.getFailureCount());
        System.out.println("Success: " + result.wasSuccessful());
    }
}
```

---

## Exception Testing

### Expected Exception

```java
@Test(expected = ArithmeticException.class)
public void testDivisionByZero() {
    int x = 1 / 0;
}
```

### Try-Catch with Assertion

```java
@Test
public void testException() {
    try {
        int x = 1 / 0;
        fail("Expected ArithmeticException");
    } catch (ArithmeticException e) {
        assertEquals("/ by zero", e.getMessage());
    }
}
```

---

## Timeout

```java
@Test(timeout = 1000)
public void testPerformance() {
    // Test must complete within 1 second
}
```

---

## Parameterized Tests

```java
@RunWith(Parameterized.class)
public class ParameterizedTest {
    
    @Parameters
    public static Collection<Object[]> data() {
        return Arrays.asList(new Object[][] {
            { 1, 1 },
            { 2, 2 },
            { 3, 3 }
        });
    }
    
    private int input;
    private int expected;
    
    public ParameterizedTest(int input, int expected) {
        this.input = input;
        this.expected = expected;
    }
    
    @Test
    public void test() {
        assertEquals(expected, input);
    }
}
```

---

## Suites

### Test Suite

```java
@RunWith(Suite.class)
@Suite.SuiteClasses({
    TestClass1.class,
    TestClass2.class,
    TestClass3.class
})
public class AllTests {
    // Run all test classes together
}
```

---

## Best Practices

1. **Test one thing per method** - Each test should verify one behavior
2. **Use descriptive names** - testMethodName_Scenario_Expected
3. **Follow AAA pattern** - Arrange, Act, Assert
4. **Keep tests independent** - No test should depend on another
5. **Test edge cases** - Null, empty, maximum values

---

## Next Steps

- Explore [JUnit 4 Documentation](https://junit.org/junit4/)
