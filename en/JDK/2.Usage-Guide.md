# JDK Usage Guide

This guide covers how to use JDK effectively for Java development.

## Basic Commands

### Compile Java

```bash
# Compile single file
javac HelloWorld.java

# Compile with custom classpath
javac -cp "lib/*" MyApp.java

# Compile to specific directory
javac -d ./build MyApp.java

# Enable all warnings
javac -Xlint:all MyApp.java
```

### Run Java

```bash
# Run compiled class
java HelloWorld

# Run with custom classpath
java -cp "lib/*:." MyApp

# Run with more memory
java -Xmx512m -Xms256m MyApp

# Run with system properties
java -Dapp.name=MyApp -Denv=prod MyApp
```

### Jar Commands

```bash
# Create JAR
jar cf myapp.jar -C out .

# Create executable JAR
jar cfe myapp.jar com.example.Main -C out .

# List JAR contents
jar tf myapp.jar

# Extract JAR
jar xf myapp.jar
```

## JVM Options

### Memory Options

```bash
# Heap size
-Xms256m          # Initial heap size
-Xmx1024m         # Maximum heap size
-Xmn128m          # Young generation size

# Metaspace (Java 8+)
-XX:MetaspaceSize=128m
-XX:MaxMetaspaceSize=256m
```

### Garbage Collection

```bash
# G1GC (default since Java 9)
-XX:+UseG1GC

# ZGC (low latency)
-XX:+UseZGC

# Parallel GC (throughput)
-XX:+UseParallelGC

# Log GC
-Xlog:gc*:file=gc.log
```

### Performance

```bash
# JIT compilation
-XX:+TieredCompilation

# String deduplication (Java 8u20+)
-XX:+UseStringDeduplication

# Class data sharing
-Xshare:on
```

## Build Tools

### Maven

```bash
# Create project
mvn archetype:generate

# Compile
mvn compile

# Run tests
mvn test

# Package
mvn package

# Run
mvn spring-boot:run
```

### Gradle

```bash
# Create project
gradle init

# Compile
gradle compileJava

# Run tests
gradle test

# Build
gradle build

# Run
gradle bootRun
```

## Module System (Java 9+)

### Module Declaration

```java
// module-info.java
module com.example.myapp {
    requires com.example.utils;
    exports com.example.api;
}
```

### Run with Modules

```bash
# List modules
java --list-modules

# Show module resolution
java --show-module-resolution

# Add module path
java --module-path lib -m com.example.myapp
```

## Security

### Keytool Commands

```bash
# Generate keystore
keytool -genkeypair -alias myapp -keyalg RSA -keysize 2048 -validity 365 -keystore keystore.jks

# List certificates
keytool -list -keystore keystore.jks

# Export certificate
keytool -exportcert -alias myapp -file myapp.crt -keystore keystore.jks
```

### Security Policy

```bash
# Set security policy
java -Djava.security.manager -Djava.security.policy=app.policy MyApp

# Disable security manager (Java 17+)
java --add-opens java.base/java.lang=ALL-UNNAMED MyApp
```

## Diagnostic Tools

### jcmd

```bash
# List Java processes
jcmd -l

# Print VM info
jcmd <pid> VM.flags

# Print system properties
jcmd <pid> VM.system_properties
```

### jstack

```bash
# Print thread dump
jstack <pid>

# Print thread dump with locks
jstack -l <pid>
```

### jmap / jhsdb

```bash
# Heap dump
jmap -dump:format=b,file=heap.bin <pid>

# Heap summary
jmap -heap <pid>

# Class histogram
jmap -histo <pid>
```

## Docker

### Dockerfile

```dockerfile
# Build image
FROM eclipse-temurin:21-jdk-alpine AS build
WORKDIR /app
COPY . .
RUN ./mvnw package -DskipTests

# Runtime image
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

### Build and Run

```bash
docker build -t myapp .
docker run -p 8080:8080 myapp
```

## Best Practices

1. **Use LTS versions** - JDK 21 or JDK 17 for production
2. **Set appropriate heap size** - Monitor and adjust based on application needs
3. **Enable GC logging** - For troubleshooting performance issues
4. **Use modular JDK** - Reduce container image size with jlink
5. **Keep updated** - Apply security patches regularly

## Related Links

- [Java Official Documentation](https://docs.oracle.com/en/java/javase/)
- [JVM Options Reference](https://docs.oracle.com/en/java/javase/21/tools/java.html)
- [Maven Central](https://maven.apache.org/)
- [Gradle](https://gradle.org/)
