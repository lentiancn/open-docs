# Часто задаваемые вопросы о Go

> Ответы на распространённые вопросы о Go

---

## Установка

### Q: Команда не найдена после установки?

**A**: 
- Проверьте, добавлен ли Go в переменную PATH
- В Windows по умолчанию устанавливается в C:\Go, нужно добавить в PATH
- В Linux/macOS обычно нужно вручную добавить в ~/.bashrc или ~/.zshrc

### Q: Как проверить, что Go установлен?

**A**: 
```bash
go version
go env GOPATH
```

### Q: Как обновить Go?

**A**: 
- Windows: Скачать и переустановить новую версию
- macOS: `brew upgrade go`
- Linux: Скачать новую версию или использовать пакетный менеджер

---

## Синтаксис

### Q: Есть ли в Go механизм исключений?

**A**: В Go нет традиционных исключений. Ошибки передаются через возвращаемые значения:
```go
result, err := doSomething()
if err != nil {
    // обработка ошибки
}
```

### Q: Почему нельзя смешивать := и var?

**A**: 
- `:=` — это короткое объявление переменной, используется внутри функций
- `var` — явное объявление, может использоваться вне функций
- Нельзя использовать оба для одной и той же переменной

### Q: Поддерживает ли Go дженерики?

**A**: Go 1.18+ поддерживает дженерики:
```go
func Print[T any](s []T) {
    for _, v := range s {
        fmt.Println(v)
    }
}
```

---

## Параллелизм

### Q: В чём разница между горутинами и потоками?

**A**: 
- Горутины управляются временем выполнения Go, легче потоков
- Создание тысяч горутин не исчерпает ресурсы
- Общение через каналы

### Q: Нужно ли закрывать каналы?

**A**: 
- Обычно отправитель закрывает канал
- Получатель может проверить, закрыт ли канал: `v, ok := <-ch`
- Не отправляйте в закрытые каналы

### Q: Как элегантно дождаться завершения горутин?

**A**: Используйте sync.WaitGroup:
```go
var wg sync.WaitGroup

for i := 0; i < 5; i++ {
    wg.Add(1)
    go func(i int) {
        defer wg.Done()
        fmt.Println(i)
    }(i)
}

wg.Wait()
```

---

## Управление пакетами

### Q: В чём разница между GOPATH и Go Modules?

**A**: 
- GOPATH: Старый метод управления зависимостями, зависимости в $GOPATH/src
- Go Module (go.mod): Современный подход, лучший контроль версий

### Q: Зависимости скачиваются медленно?

**A**: 
```bash
# Использовать китайское зеркало
go env -w GOPROXY=https://goproxy.cn,direct

# Также можно настроить
go env -w GOPROXY=https://proxy.golang.org,direct
```

### Q: Как посмотреть зависимости?

**A**: 
```bash
go mod graph
go list -m all
```

---

## Производительность

### Q: Как проводить профилирование?

**A**: 
```bash
# Профилирование CPU
go test -cpuprofile=cpu.out

# Профилирование памяти
go test -memprofile=mem.out

# Анализ с pprof
go tool pprof cpu.out
```

### Q: Как оптимизировать программы на Go?

**A**: 
- Использовать strings.Builder для объединения строк
- Избегать ненужных выделений памяти
- Использовать пулы (sync.Pool) для повторного использования объектов
- Эффективно использовать каналы

---

## Инструменты

### Q: В чём разница между go fmt и go vet?

**A**: 
- go fmt: Форматирует стиль кода
- go vet: Статический анализ, проверка на потенциальные ошибки

### Q: Как генерировать документацию?

**A**: 
```bash
go doc <имя-пакета>
go doc <имя-функции>

# Локальный сервер документации
go doc -http=:6060
```

---

## Ошибки

### Q: Какие распространённые ошибки компиляции?

**A**: 
- `undefined: xxx` — переменная не определена
- `mismatched types` — типы не совпадают
- `invalid character` — проблема с кодировкой
- `package xxx is not in GOROOT` — ошибка пути пакета

### Q: Что делать при runtime panic?

**A**: 
- Использовать defer и recover:
```go
func safeCall() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Восстановлено:", r)
        }
    }()
    // код, который может вызвать panic
}
```
